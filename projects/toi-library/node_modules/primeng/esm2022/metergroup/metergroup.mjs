import { CommonModule } from '@angular/common';
import { ChangeDetectionStrategy, Component, ContentChild, ContentChildren, ElementRef, forwardRef, inject, Input, NgModule, ViewChild, ViewEncapsulation } from '@angular/core';
import { getOuterHeight } from '@primeuix/utils';
import { PrimeTemplate, SharedModule } from 'primeng/api';
import { BaseComponent } from 'primeng/basecomponent';
import { MeterGroupStyle } from './style/metergroupstyle';
import * as i0 from "@angular/core";
import * as i1 from "@angular/common";
const _c0 = (a0, a1) => ({ $implicit: a0, icon: a1 });
const _c1 = () => ({ "p-metergroup-label-icon": true });
const _c2 = a0 => ({ color: a0 });
const _c3 = a0 => ({ backgroundColor: a0 });
function MeterGroupLabel_li_1_ng_container_1_i_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "i", 8);
} if (rf & 2) {
    const labelItem_r1 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵclassMap(labelItem_r1.icon);
    i0.ɵɵproperty("ngClass", i0.ɵɵpureFunction0(4, _c1))("ngStyle", i0.ɵɵpureFunction1(5, _c2, labelItem_r1.color));
} }
function MeterGroupLabel_li_1_ng_container_1_span_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "span", 9);
} if (rf & 2) {
    const labelItem_r1 = i0.ɵɵnextContext(2).$implicit;
    i0.ɵɵproperty("ngStyle", i0.ɵɵpureFunction1(1, _c3, labelItem_r1.color));
} }
function MeterGroupLabel_li_1_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, MeterGroupLabel_li_1_ng_container_1_i_1_Template, 1, 7, "i", 6)(2, MeterGroupLabel_li_1_ng_container_1_span_2_Template, 1, 3, "span", 7);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const labelItem_r1 = i0.ɵɵnextContext().$implicit;
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", labelItem_r1.icon);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !labelItem_r1.icon);
} }
function MeterGroupLabel_li_1_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroupLabel_li_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementStart(0, "li", 2);
    i0.ɵɵtemplate(1, MeterGroupLabel_li_1_ng_container_1_Template, 3, 2, "ng-container", 3)(2, MeterGroupLabel_li_1_ng_container_2_Template, 1, 0, "ng-container", 4);
    i0.ɵɵelementStart(3, "span", 5);
    i0.ɵɵtext(4);
    i0.ɵɵelementEnd()();
} if (rf & 2) {
    const labelItem_r1 = ctx.$implicit;
    const ctx_r1 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r1.iconTemplate);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r1.iconTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction2(5, _c0, labelItem_r1, labelItem_r1.icon));
    i0.ɵɵadvance(2);
    i0.ɵɵtextInterpolate2("", labelItem_r1.label, " (", ctx_r1.parentInstance.percentValue(labelItem_r1.value), ")");
} }
const _c4 = ["label"];
const _c5 = ["meter"];
const _c6 = ["end"];
const _c7 = ["start"];
const _c8 = ["icon"];
const _c9 = ["container"];
const _c10 = (a0, a1, a2) => ({ $implicit: a0, totalPercent: a1, percentages: a2 });
const _c11 = (a0, a1, a2, a3, a4) => ({ $implicit: a0, index: a1, orientation: a2, class: "p-metergroup-meter", size: a3, totalPercent: a4 });
function MeterGroup_Conditional_2_p_meterGroupLabel_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "p-meterGroupLabel", 6);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("value", ctx_r0.value)("labelPosition", ctx_r0.labelPosition)("labelOrientation", ctx_r0.labelOrientation)("min", ctx_r0.min)("max", ctx_r0.max)("iconTemplate", ctx_r0.iconTemplate || ctx_r0._iconTemplate);
} }
function MeterGroup_Conditional_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroup_Conditional_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, MeterGroup_Conditional_2_p_meterGroupLabel_0_Template, 1, 6, "p-meterGroupLabel", 5)(1, MeterGroup_Conditional_2_ng_container_1_Template, 1, 0, "ng-container", 2);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", !ctx_r0.labelTemplate && !ctx_r0._labelTemplate);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplate || ctx_r0.labelTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(3, _c10, ctx_r0.value, ctx_r0.totalPercent(), ctx_r0.percentages()));
} }
function MeterGroup_ng_container_3_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroup_ng_container_5_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroup_ng_container_5_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵelement(1, "span", 8);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const meterItem_r2 = i0.ɵɵnextContext().$implicit;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngStyle", ctx_r0.meterStyle(meterItem_r2));
} }
function MeterGroup_ng_container_5_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainerStart(0);
    i0.ɵɵtemplate(1, MeterGroup_ng_container_5_ng_container_1_Template, 1, 0, "ng-container", 2)(2, MeterGroup_ng_container_5_ng_container_2_Template, 2, 1, "ng-container", 7);
    i0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const meterItem_r2 = ctx.$implicit;
    const index_r3 = ctx.index;
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.meterTemplate || ctx_r0._meterTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction5(3, _c11, meterItem_r2, index_r3, ctx_r0.orientation, ctx_r0.percentValue(meterItem_r2.value), ctx_r0.totalPercent()));
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngIf", !ctx_r0.meterTemplate && !ctx_r0._meterTemplate && meterItem_r2.value > 0);
} }
function MeterGroup_ng_container_6_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroup_Conditional_7_p_meterGroupLabel_0_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelement(0, "p-meterGroupLabel", 6);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext(2);
    i0.ɵɵproperty("value", ctx_r0.value)("labelPosition", ctx_r0.labelPosition)("labelOrientation", ctx_r0.labelOrientation)("min", ctx_r0.min)("max", ctx_r0.max)("iconTemplate", ctx_r0.iconTemplate || ctx_r0._iconTemplate);
} }
function MeterGroup_Conditional_7_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵelementContainer(0);
} }
function MeterGroup_Conditional_7_Template(rf, ctx) { if (rf & 1) {
    i0.ɵɵtemplate(0, MeterGroup_Conditional_7_p_meterGroupLabel_0_Template, 1, 6, "p-meterGroupLabel", 5)(1, MeterGroup_Conditional_7_ng_container_1_Template, 1, 0, "ng-container", 2);
} if (rf & 2) {
    const ctx_r0 = i0.ɵɵnextContext();
    i0.ɵɵproperty("ngIf", !ctx_r0.labelTemplate && !ctx_r0._labelTemplate);
    i0.ɵɵadvance();
    i0.ɵɵproperty("ngTemplateOutlet", ctx_r0.labelTemplate || ctx_r0._labelTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(3, _c10, ctx_r0.value, ctx_r0.totalPercent(), ctx_r0.percentages()));
} }
export class MeterGroupLabel {
    value = null;
    labelPosition = 'end';
    labelOrientation = 'horizontal';
    min;
    max;
    iconTemplate;
    get labelClass() {
        return {
            'p-metergroup-label-list p-component': true,
            'p-metergroup-label-list-vertical': this.labelOrientation === 'vertical',
            'p-metergroup-label-list-horizontal': this.labelOrientation === 'horizontal'
        };
    }
    parentInstance = inject(forwardRef(() => MeterGroup));
    static ɵfac = function MeterGroupLabel_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MeterGroupLabel)(); };
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MeterGroupLabel, selectors: [["p-meterGroupLabel"], ["p-metergrouplabel"]], inputs: { value: "value", labelPosition: "labelPosition", labelOrientation: "labelOrientation", min: "min", max: "max", iconTemplate: "iconTemplate" }, standalone: true, features: [i0.ɵɵStandaloneFeature], decls: 2, vars: 3, consts: [[3, "ngClass"], ["class", "p-metergroup-label", 4, "ngFor", "ngForOf", "ngForTrackBy"], [1, "p-metergroup-label"], [4, "ngIf"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "p-metergroup-label-text"], [3, "class", "ngClass", "ngStyle", 4, "ngIf"], ["class", "p-metergroup-label-marker", 3, "ngStyle", 4, "ngIf"], [3, "ngClass", "ngStyle"], [1, "p-metergroup-label-marker", 3, "ngStyle"]], template: function MeterGroupLabel_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "ol", 0);
            i0.ɵɵtemplate(1, MeterGroupLabel_li_1_Template, 5, 8, "li", 1);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵproperty("ngClass", ctx.labelClass);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngForOf", ctx.value)("ngForTrackBy", ctx.parentInstance.trackByFn);
        } }, dependencies: [CommonModule, i1.NgClass, i1.NgForOf, i1.NgIf, i1.NgTemplateOutlet, i1.NgStyle, SharedModule], encapsulation: 2 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeterGroupLabel, [{
        type: Component,
        args: [{
                selector: 'p-meterGroupLabel, p-metergrouplabel',
                standalone: true,
                imports: [CommonModule, SharedModule],
                template: `
        <ol [ngClass]="labelClass">
            <li *ngFor="let labelItem of value; let index = index; trackBy: parentInstance.trackByFn" class="p-metergroup-label">
                <ng-container *ngIf="!iconTemplate">
                    <i *ngIf="labelItem.icon" [class]="labelItem.icon" [ngClass]="{ 'p-metergroup-label-icon': true }" [ngStyle]="{ color: labelItem.color }"></i>
                    <span *ngIf="!labelItem.icon" class="p-metergroup-label-marker" [ngStyle]="{ backgroundColor: labelItem.color }"></span>
                </ng-container>
                <ng-container *ngTemplateOutlet="iconTemplate; context: { $implicit: labelItem, icon: labelItem.icon }"></ng-container>
                <span class="p-metergroup-label-text">{{ labelItem.label }} ({{ parentInstance.percentValue(labelItem.value) }})</span>
            </li>
        </ol>
    `
            }]
    }], null, { value: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], labelOrientation: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], iconTemplate: [{
            type: Input
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(MeterGroupLabel, { className: "MeterGroupLabel" }); })();
/**
 * MeterGroup displays scalar measurements within a known range.
 * @group Components
 */
export class MeterGroup extends BaseComponent {
    /**
     * Current value of the metergroup.
     * @group Props
     */
    value;
    /**
     * Mininum boundary value.
     * @group Props
     */
    min = 0;
    /**
     * Maximum boundary value.
     * @group Props
     */
    max = 100;
    /**
     * Specifies the layout of the component, valid values are 'horizontal' and 'vertical'.
     * @group Props
     */
    orientation = 'horizontal';
    /**
     * Specifies the label position of the component, valid values are 'start' and 'end'.
     * @group Props
     */
    labelPosition = 'end';
    /**
     * Specifies the label orientation of the component, valid values are 'horizontal' and 'vertical'.
     * @group Props
     */
    labelOrientation = 'horizontal';
    /**
     * Inline style of the element.
     * @group Props
     */
    style;
    /**
     * Style class of the element.
     * @group Props
     */
    styleClass;
    get vertical() {
        return this.orientation === 'vertical';
    }
    get containerClass() {
        return {
            'p-metergroup p-component': true,
            'p-metergroup-horizontal': this.orientation === 'horizontal',
            'p-metergroup-vertical': this.orientation === 'vertical'
        };
    }
    labelTemplate;
    meterTemplate;
    endTemplate;
    startTemplate;
    iconTemplate;
    templates;
    _labelTemplate;
    _meterTemplate;
    _endTemplate;
    _startTemplate;
    _iconTemplate;
    _componentStyle = inject(MeterGroupStyle);
    container;
    ngAfterViewInit() {
        super.ngAfterViewInit();
        const _container = this.container.nativeElement;
        const height = getOuterHeight(_container);
        this.vertical && (_container.style.height = height + 'px');
    }
    ngAfterContentInit() {
        this.templates?.forEach((item) => {
            switch (item.getType()) {
                case 'label':
                    this._labelTemplate = item.template;
                    break;
                case 'meter':
                    this._meterTemplate = item.template;
                    break;
                case 'icon':
                    this._iconTemplate = item.template;
                    break;
                case 'start':
                    this._startTemplate = item.template;
                    break;
                case 'end':
                    this._endTemplate = item.template;
                    break;
            }
        });
    }
    percent(meter = 0) {
        const percentOfItem = ((meter - this.min) / (this.max - this.min)) * 100;
        return Math.round(Math.max(0, Math.min(100, percentOfItem)));
    }
    percentValue(meter) {
        return this.percent(meter) + '%';
    }
    meterStyle(val) {
        return {
            backgroundColor: val.color,
            width: this.orientation === 'horizontal' && this.percentValue(val.value),
            height: this.orientation === 'vertical' && this.percentValue(val.value)
        };
    }
    totalPercent() {
        return this.percent(this.value.reduce((total, val) => total + val.value, 0));
    }
    percentages() {
        let sum = 0;
        const sumsArray = [];
        this.value.forEach((item) => {
            sum += item.value;
            sumsArray.push(sum);
        });
        return sumsArray;
    }
    trackByFn(index) {
        return index;
    }
    static ɵfac = /*@__PURE__*/ (() => { let ɵMeterGroup_BaseFactory; return function MeterGroup_Factory(__ngFactoryType__) { return (ɵMeterGroup_BaseFactory || (ɵMeterGroup_BaseFactory = i0.ɵɵgetInheritedFactory(MeterGroup)))(__ngFactoryType__ || MeterGroup); }; })();
    static ɵcmp = /*@__PURE__*/ i0.ɵɵdefineComponent({ type: MeterGroup, selectors: [["p-meterGroup"], ["p-metergroup"], ["p-meter-group"]], contentQueries: function MeterGroup_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
            i0.ɵɵcontentQuery(dirIndex, _c4, 4);
            i0.ɵɵcontentQuery(dirIndex, _c5, 4);
            i0.ɵɵcontentQuery(dirIndex, _c6, 4);
            i0.ɵɵcontentQuery(dirIndex, _c7, 4);
            i0.ɵɵcontentQuery(dirIndex, _c8, 4);
            i0.ɵɵcontentQuery(dirIndex, PrimeTemplate, 4);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.labelTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.meterTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.endTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.startTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.iconTemplate = _t.first);
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.templates = _t);
        } }, viewQuery: function MeterGroup_Query(rf, ctx) { if (rf & 1) {
            i0.ɵɵviewQuery(_c9, 5, ElementRef);
        } if (rf & 2) {
            let _t;
            i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.container = _t.first);
        } }, inputs: { value: "value", min: "min", max: "max", orientation: "orientation", labelPosition: "labelPosition", labelOrientation: "labelOrientation", style: "style", styleClass: "styleClass" }, standalone: true, features: [i0.ɵɵProvidersFeature([MeterGroupStyle]), i0.ɵɵInheritDefinitionFeature, i0.ɵɵStandaloneFeature], decls: 8, vars: 24, consts: [["container", ""], [3, "ngClass", "ngStyle"], [4, "ngTemplateOutlet", "ngTemplateOutletContext"], [1, "p-metergroup-meters"], [4, "ngFor", "ngForOf", "ngForTrackBy"], [3, "value", "labelPosition", "labelOrientation", "min", "max", "iconTemplate", 4, "ngIf"], [3, "value", "labelPosition", "labelOrientation", "min", "max", "iconTemplate"], [4, "ngIf"], [1, "p-metergroup-meter", 3, "ngStyle"]], template: function MeterGroup_Template(rf, ctx) { if (rf & 1) {
            i0.ɵɵelementStart(0, "div", 1, 0);
            i0.ɵɵtemplate(2, MeterGroup_Conditional_2_Template, 2, 7)(3, MeterGroup_ng_container_3_Template, 1, 0, "ng-container", 2);
            i0.ɵɵelementStart(4, "div", 3);
            i0.ɵɵtemplate(5, MeterGroup_ng_container_5_Template, 3, 9, "ng-container", 4);
            i0.ɵɵelementEnd();
            i0.ɵɵtemplate(6, MeterGroup_ng_container_6_Template, 1, 0, "ng-container", 2)(7, MeterGroup_Conditional_7_Template, 2, 7);
            i0.ɵɵelementEnd();
        } if (rf & 2) {
            i0.ɵɵclassMap(ctx.styleClass);
            i0.ɵɵproperty("ngClass", ctx.containerClass)("ngStyle", ctx.style);
            i0.ɵɵattribute("role", "meter")("aria-valuemin", ctx.min)("aria-valuemax", ctx.max)("aria-valuenow", ctx.totalPercent());
            i0.ɵɵadvance(2);
            i0.ɵɵconditional(ctx.labelPosition === "start" ? 2 : -1);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngTemplateOutlet", ctx.startTemplate || ctx._startTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(16, _c10, ctx.value, ctx.totalPercent(), ctx.percentages()));
            i0.ɵɵadvance(2);
            i0.ɵɵproperty("ngForOf", ctx.value)("ngForTrackBy", ctx.trackByFn);
            i0.ɵɵadvance();
            i0.ɵɵproperty("ngTemplateOutlet", ctx.endTemplate || ctx._endTemplate)("ngTemplateOutletContext", i0.ɵɵpureFunction3(20, _c10, ctx.value, ctx.totalPercent(), ctx.percentages()));
            i0.ɵɵadvance();
            i0.ɵɵconditional(ctx.labelPosition === "end" ? 7 : -1);
        } }, dependencies: [CommonModule, i1.NgClass, i1.NgForOf, i1.NgIf, i1.NgTemplateOutlet, i1.NgStyle, MeterGroupLabel, SharedModule], encapsulation: 2, changeDetection: 0 });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeterGroup, [{
        type: Component,
        args: [{
                selector: 'p-meterGroup, p-metergroup, p-meter-group',
                standalone: true,
                imports: [CommonModule, MeterGroupLabel, SharedModule],
                template: `
        <div #container [ngClass]="containerClass" [attr.role]="'meter'" [attr.aria-valuemin]="min" [attr.aria-valuemax]="max" [attr.aria-valuenow]="totalPercent()" [ngStyle]="style" [class]="styleClass">
            @if (labelPosition === 'start') {
                <p-meterGroupLabel *ngIf="!labelTemplate && !_labelTemplate" [value]="value" [labelPosition]="labelPosition" [labelOrientation]="labelOrientation" [min]="min" [max]="max" [iconTemplate]="iconTemplate || _iconTemplate" />
                <ng-container *ngTemplateOutlet="labelTemplate || labelTemplate; context: { $implicit: value, totalPercent: totalPercent(), percentages: percentages() }"></ng-container>
            }
            <ng-container *ngTemplateOutlet="startTemplate || _startTemplate; context: { $implicit: value, totalPercent: totalPercent(), percentages: percentages() }"></ng-container>
            <div class="p-metergroup-meters">
                <ng-container *ngFor="let meterItem of value; let index = index; trackBy: trackByFn">
                    <ng-container
                        *ngTemplateOutlet="
                            meterTemplate || _meterTemplate;
                            context: {
                                $implicit: meterItem,
                                index: index,
                                orientation: this.orientation,
                                class: 'p-metergroup-meter',
                                size: percentValue(meterItem.value),
                                totalPercent: totalPercent()
                            }
                        "
                    >
                    </ng-container>
                    <ng-container *ngIf="!meterTemplate && !_meterTemplate && meterItem.value > 0">
                        <span class="p-metergroup-meter" [ngStyle]="meterStyle(meterItem)"></span>
                    </ng-container>
                </ng-container>
            </div>
            <ng-container *ngTemplateOutlet="endTemplate || _endTemplate; context: { $implicit: value, totalPercent: totalPercent(), percentages: percentages() }"></ng-container>
            @if (labelPosition === 'end') {
                <p-meterGroupLabel *ngIf="!labelTemplate && !_labelTemplate" [value]="value" [labelPosition]="labelPosition" [labelOrientation]="labelOrientation" [min]="min" [max]="max" [iconTemplate]="iconTemplate || _iconTemplate" />
                <ng-container *ngTemplateOutlet="labelTemplate || _labelTemplate; context: { $implicit: value, totalPercent: totalPercent(), percentages: percentages() }"></ng-container>
            }
        </div>
    `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                providers: [MeterGroupStyle]
            }]
    }], null, { value: [{
            type: Input
        }], min: [{
            type: Input
        }], max: [{
            type: Input
        }], orientation: [{
            type: Input
        }], labelPosition: [{
            type: Input
        }], labelOrientation: [{
            type: Input
        }], style: [{
            type: Input
        }], styleClass: [{
            type: Input
        }], labelTemplate: [{
            type: ContentChild,
            args: ['label', { descendants: false }]
        }], meterTemplate: [{
            type: ContentChild,
            args: ['meter', { descendants: false }]
        }], endTemplate: [{
            type: ContentChild,
            args: ['end', { descendants: false }]
        }], startTemplate: [{
            type: ContentChild,
            args: ['start', { descendants: false }]
        }], iconTemplate: [{
            type: ContentChild,
            args: ['icon', { descendants: false }]
        }], templates: [{
            type: ContentChildren,
            args: [PrimeTemplate]
        }], container: [{
            type: ViewChild,
            args: ['container', { read: ElementRef }]
        }] }); })();
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassDebugInfo(MeterGroup, { className: "MeterGroup" }); })();
export class MeterGroupModule {
    static ɵfac = function MeterGroupModule_Factory(__ngFactoryType__) { return new (__ngFactoryType__ || MeterGroupModule)(); };
    static ɵmod = /*@__PURE__*/ i0.ɵɵdefineNgModule({ type: MeterGroupModule });
    static ɵinj = /*@__PURE__*/ i0.ɵɵdefineInjector({ imports: [MeterGroup, SharedModule, SharedModule] });
}
(() => { (typeof ngDevMode === "undefined" || ngDevMode) && i0.ɵsetClassMetadata(MeterGroupModule, [{
        type: NgModule,
        args: [{
                imports: [MeterGroup, SharedModule],
                exports: [MeterGroup, SharedModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && i0.ɵɵsetNgModuleScope(MeterGroupModule, { imports: [MeterGroup, SharedModule], exports: [MeterGroup, SharedModule] }); })();
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0ZXJncm91cC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9tZXRlcmdyb3VwL21ldGVyZ3JvdXAudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFFLFlBQVksRUFBRSxNQUFNLGlCQUFpQixDQUFDO0FBQy9DLE9BQU8sRUFBb0IsdUJBQXVCLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxlQUFlLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBMEIsU0FBUyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNOLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNqRCxPQUFPLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxNQUFNLGFBQWEsQ0FBQztBQUMxRCxPQUFPLEVBQUUsYUFBYSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFFdEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7Ozs7OztJQVV0Qyx1QkFBOEk7OztJQUFwSCxnQ0FBd0I7SUFBaUQsQUFBaEQsb0RBQStDLDJEQUF1Qzs7O0lBQ3pJLDBCQUF3SDs7O0lBQXhELHdFQUFnRDs7O0lBRnBILDZCQUFvQztJQUVoQyxBQURBLGdGQUEwSSx5RUFDekI7Ozs7SUFEN0csY0FBb0I7SUFBcEIsd0NBQW9CO0lBQ2pCLGNBQXFCO0lBQXJCLHlDQUFxQjs7O0lBRWhDLHdCQUF1SDs7O0lBTDNILDZCQUFxSDtJQUtqSCxBQUpBLHVGQUFvQywwRUFJb0U7SUFDeEcsK0JBQXNDO0lBQUEsWUFBMEU7SUFDcEgsQUFEb0gsaUJBQU8sRUFDdEg7Ozs7SUFOYyxjQUFtQjtJQUFuQiwyQ0FBbUI7SUFJbkIsY0FBZ0M7SUFBQSxBQUFoQyxzREFBZ0Msd0ZBQXVEO0lBQ2hFLGVBQTBFO0lBQTFFLGdIQUEwRTs7Ozs7Ozs7Ozs7SUF1Q2hILHVDQUE0Tjs7O0lB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VUFBVSxFQUFFLFlBQVksRUFDWixZQUFZOztpRkFFekIsZ0JBQWdCO2NBSjVCLFFBQVE7ZUFBQztnQkFDTixPQUFPLEVBQUUsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDO2dCQUNuQyxPQUFPLEVBQUUsQ0FBQyxVQUFVLEVBQUUsWUFBWSxDQUFDO2FBQ3RDOzt3RkFDWSxnQkFBZ0IsY0E1SmhCLFVBQVUsRUF5SkcsWUFBWSxhQXpKekIsVUFBVSxFQTBKRyxZQUFZIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQ29tbW9uTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29tbW9uJztcbmltcG9ydCB7IEFmdGVyQ29udGVudEluaXQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBDb21wb25lbnQsIENvbnRlbnRDaGlsZCwgQ29udGVudENoaWxkcmVuLCBFbGVtZW50UmVmLCBmb3J3YXJkUmVmLCBpbmplY3QsIElucHV0LCBOZ01vZHVsZSwgUXVlcnlMaXN0LCBUZW1wbGF0ZVJlZiwgVmlld0NoaWxkLCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgZ2V0T3V0ZXJIZWlnaHQgfSBmcm9tICdAcHJpbWV1aXgvdXRpbHMnO1xuaW1wb3J0IHsgUHJpbWVUZW1wbGF0ZSwgU2hhcmVkTW9kdWxlIH0gZnJvbSAncHJpbWVuZy9hcGknO1xuaW1wb3J0IHsgQmFzZUNvbXBvbmVudCB9IGZyb20gJ3ByaW1lbmcvYmFzZWNvbXBvbmVudCc7XG5pbXBvcnQgeyBNZXRlckl0ZW0gfSBmcm9tICcuL21ldGVyZ3JvdXAuaW50ZXJmYWNlJztcbmltcG9ydCB7IE1ldGVyR3JvdXBTdHlsZSB9IGZyb20gJy4vc3R5bGUvbWV0ZXJncm91cHN0eWxlJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdwLW1ldGVyR3JvdXBMYWJlbCwgcC1tZXRlcmdyb3VwbGFiZWwnLFxuICAgIHN0YW5kYWxvbmU6IHRydWUsXG4gICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgU2hhcmVkTW9kdWxlXSxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8b2wgW25nQ2xhc3NdPVwibGFiZWxDbGFzc1wiPlxuICAgICAgICAgICAgPGxpICpuZ0Zvcj1cImxldCBsYWJlbEl0ZW0gb2YgdmFsdWU7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiBwYXJlbnRJbnN0YW5jZS50cmFja0J5Rm5cIiBjbGFzcz1cInAtbWV0ZXJncm91cC1sYWJlbFwiPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nSWY9XCIhaWNvblRlbXBsYXRlXCI+XG4gICAgICAgICAgICAgICAgICAgIDxpICpuZ0lmPVwibGFiZWxJdGVtLmljb25cIiBbY2xhc3NdPVwibGFiZWxJdGVtLmljb25cIiBbbmdDbGFzc109XCJ7ICdwLW1ldGVyZ3JvdXAtbGFiZWwtaWNvbic6IHRydWUgfVwiIFtuZ1N0eWxlXT1cInsgY29sb3I6IGxhYmVsSXRlbS5jb2xvciB9XCI+PC9pPlxuICAgICAgICAgICAgICAgICAgICA8c3BhbiAqbmdJZj1cIiFsYWJlbEl0ZW0uaWNvblwiIGNsYXNzPVwicC1tZXRlcmdyb3VwLWxhYmVsLW1hcmtlclwiIFtuZ1N0eWxlXT1cInsgYmFja2dyb3VuZENvbG9yOiBsYWJlbEl0ZW0uY29sb3IgfVwiPjwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ1RlbXBsYXRlT3V0bGV0PVwiaWNvblRlbXBsYXRlOyBjb250ZXh0OiB7ICRpbXBsaWNpdDogbGFiZWxJdGVtLCBpY29uOiBsYWJlbEl0ZW0uaWNvbiB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJwLW1ldGVyZ3JvdXAtbGFiZWwtdGV4dFwiPnt7IGxhYmVsSXRlbS5sYWJlbCB9fSAoe3sgcGFyZW50SW5zdGFuY2UucGVyY2VudFZhbHVlKGxhYmVsSXRlbS52YWx1ZSkgfX0pPC9zcGFuPlxuICAgICAgICAgICAgPC9saT5cbiAgICAgICAgPC9vbD5cbiAgICBgXG59KVxuZXhwb3J0IGNsYXNzIE1ldGVyR3JvdXBMYWJlbCB7XG4gICAgQElucHV0KCkgdmFsdWU6IGFueVtdID0gbnVsbDtcblxuICAgIEBJbnB1dCgpIGxhYmVsUG9zaXRpb246ICdzdGFydCcgfCAnZW5kJyA9ICdlbmQnO1xuXG4gICAgQElucHV0KCkgbGFiZWxPcmllbnRhdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyA9ICdob3Jpem9udGFsJztcblxuICAgIEBJbnB1dCgpIG1pbjogbnVtYmVyO1xuXG4gICAgQElucHV0KCkgbWF4OiBudW1iZXI7XG5cbiAgICBASW5wdXQoKSBpY29uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBnZXQgbGFiZWxDbGFzcygpOiB7IFtrZXk6IHN0cmluZ106IGJvb2xlYW4gfSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAncC1tZXRlcmdyb3VwLWxhYmVsLWxpc3QgcC1jb21wb25lbnQnOiB0cnVlLFxuICAgICAgICAgICAgJ3AtbWV0ZXJncm91cC1sYWJlbC1saXN0LXZlcnRpY2FsJzogdGhpcy5sYWJlbE9yaWVudGF0aW9uID09PSAndmVydGljYWwnLFxuICAgICAgICAgICAgJ3AtbWV0ZXJncm91cC1sYWJlbC1saXN0LWhvcml6b250YWwnOiB0aGlzLmxhYmVsT3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJ1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIHBhcmVudEluc3RhbmNlOiBNZXRlckdyb3VwID0gaW5qZWN0KGZvcndhcmRSZWYoKCkgPT4gTWV0ZXJHcm91cCkpO1xufVxuLyoqXG4gKiBNZXRlckdyb3VwIGRpc3BsYXlzIHNjYWxhciBtZWFzdXJlbWVudHMgd2l0aGluIGEga25vd24gcmFuZ2UuXG4gKiBAZ3JvdXAgQ29tcG9uZW50c1xuICovXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ3AtbWV0ZXJHcm91cCwgcC1tZXRlcmdyb3VwLCBwLW1ldGVyLWdyb3VwJyxcbiAgICBzdGFuZGFsb25lOiB0cnVlLFxuICAgIGltcG9ydHM6IFtDb21tb25Nb2R1bGUsIE1ldGVyR3JvdXBMYWJlbCwgU2hhcmVkTW9kdWxlXSxcbiAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8ZGl2ICNjb250YWluZXIgW25nQ2xhc3NdPVwiY29udGFpbmVyQ2xhc3NcIiBbYXR0ci5yb2xlXT1cIidtZXRlcidcIiBbYXR0ci5hcmlhLXZhbHVlbWluXT1cIm1pblwiIFthdHRyLmFyaWEtdmFsdWVtYXhdPVwibWF4XCIgW2F0dHIuYXJpYS12YWx1ZW5vd109XCJ0b3RhbFBlcmNlbnQoKVwiIFtuZ1N0eWxlXT1cInN0eWxlXCIgW2NsYXNzXT1cInN0eWxlQ2xhc3NcIj5cbiAgICAgICAgICAgIEBpZiAobGFiZWxQb3NpdGlvbiA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICAgICAgICAgIDxwLW1ldGVyR3JvdXBMYWJlbCAqbmdJZj1cIiFsYWJlbFRlbXBsYXRlICYmICFfbGFiZWxUZW1wbGF0ZVwiIFt2YWx1ZV09XCJ2YWx1ZVwiIFtsYWJlbFBvc2l0aW9uXT1cImxhYmVsUG9zaXRpb25cIiBbbGFiZWxPcmllbnRhdGlvbl09XCJsYWJlbE9yaWVudGF0aW9uXCIgW21pbl09XCJtaW5cIiBbbWF4XT1cIm1heFwiIFtpY29uVGVtcGxhdGVdPVwiaWNvblRlbXBsYXRlIHx8IF9pY29uVGVtcGxhdGVcIiAvPlxuICAgICAgICAgICAgICAgIDxuZy1jb250YWluZXIgKm5nVGVtcGxhdGVPdXRsZXQ9XCJsYWJlbFRlbXBsYXRlIHx8IGxhYmVsVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB2YWx1ZSwgdG90YWxQZXJjZW50OiB0b3RhbFBlcmNlbnQoKSwgcGVyY2VudGFnZXM6IHBlcmNlbnRhZ2VzKCkgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cInN0YXJ0VGVtcGxhdGUgfHwgX3N0YXJ0VGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB2YWx1ZSwgdG90YWxQZXJjZW50OiB0b3RhbFBlcmNlbnQoKSwgcGVyY2VudGFnZXM6IHBlcmNlbnRhZ2VzKCkgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cInAtbWV0ZXJncm91cC1tZXRlcnNcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBtZXRlckl0ZW0gb2YgdmFsdWU7IGxldCBpbmRleCA9IGluZGV4OyB0cmFja0J5OiB0cmFja0J5Rm5cIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICAgICAgKm5nVGVtcGxhdGVPdXRsZXQ9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRlclRlbXBsYXRlIHx8IF9tZXRlclRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJGltcGxpY2l0OiBtZXRlckl0ZW0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb3JpZW50YXRpb246IHRoaXMub3JpZW50YXRpb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiAncC1tZXRlcmdyb3VwLW1ldGVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2l6ZTogcGVyY2VudFZhbHVlKG1ldGVySXRlbS52YWx1ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvdGFsUGVyY2VudDogdG90YWxQZXJjZW50KClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICAgIDwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIW1ldGVyVGVtcGxhdGUgJiYgIV9tZXRlclRlbXBsYXRlICYmIG1ldGVySXRlbS52YWx1ZSA+IDBcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwicC1tZXRlcmdyb3VwLW1ldGVyXCIgW25nU3R5bGVdPVwibWV0ZXJTdHlsZShtZXRlckl0ZW0pXCI+PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgICAgICA8L25nLWNvbnRhaW5lcj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImVuZFRlbXBsYXRlIHx8IF9lbmRUZW1wbGF0ZTsgY29udGV4dDogeyAkaW1wbGljaXQ6IHZhbHVlLCB0b3RhbFBlcmNlbnQ6IHRvdGFsUGVyY2VudCgpLCBwZXJjZW50YWdlczogcGVyY2VudGFnZXMoKSB9XCI+PC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICBAaWYgKGxhYmVsUG9zaXRpb24gPT09ICdlbmQnKSB7XG4gICAgICAgICAgICAgICAgPHAtbWV0ZXJHcm91cExhYmVsICpuZ0lmPVwiIWxhYmVsVGVtcGxhdGUgJiYgIV9sYWJlbFRlbXBsYXRlXCIgW3ZhbHVlXT1cInZhbHVlXCIgW2xhYmVsUG9zaXRpb25dPVwibGFiZWxQb3NpdGlvblwiIFtsYWJlbE9yaWVudGF0aW9uXT1cImxhYmVsT3JpZW50YXRpb25cIiBbbWluXT1cIm1pblwiIFttYXhdPVwibWF4XCIgW2ljb25UZW1wbGF0ZV09XCJpY29uVGVtcGxhdGUgfHwgX2ljb25UZW1wbGF0ZVwiIC8+XG4gICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdUZW1wbGF0ZU91dGxldD1cImxhYmVsVGVtcGxhdGUgfHwgX2xhYmVsVGVtcGxhdGU7IGNvbnRleHQ6IHsgJGltcGxpY2l0OiB2YWx1ZSwgdG90YWxQZXJjZW50OiB0b3RhbFBlcmNlbnQoKSwgcGVyY2VudGFnZXM6IHBlcmNlbnRhZ2VzKCkgfVwiPjwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgfVxuICAgICAgICA8L2Rpdj5cbiAgICBgLFxuICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgIGVuY2Fwc3VsYXRpb246IFZpZXdFbmNhcHN1bGF0aW9uLk5vbmUsXG4gICAgcHJvdmlkZXJzOiBbTWV0ZXJHcm91cFN0eWxlXVxufSlcbmV4cG9ydCBjbGFzcyBNZXRlckdyb3VwIGV4dGVuZHMgQmFzZUNvbXBvbmVudCBpbXBsZW1lbnRzIEFmdGVyQ29udGVudEluaXQge1xuICAgIC8qKlxuICAgICAqIEN1cnJlbnQgdmFsdWUgb2YgdGhlIG1ldGVyZ3JvdXAuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgdmFsdWU6IE1ldGVySXRlbVtdIHwgdW5kZWZpbmVkO1xuICAgIC8qKlxuICAgICAqIE1pbmludW0gYm91bmRhcnkgdmFsdWUuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgbWluOiBudW1iZXIgPSAwO1xuICAgIC8qKlxuICAgICAqIE1heGltdW0gYm91bmRhcnkgdmFsdWUuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgbWF4OiBudW1iZXIgPSAxMDA7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBsYXlvdXQgb2YgdGhlIGNvbXBvbmVudCwgdmFsaWQgdmFsdWVzIGFyZSAnaG9yaXpvbnRhbCcgYW5kICd2ZXJ0aWNhbCcuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgb3JpZW50YXRpb246ICdob3Jpem9udGFsJyB8ICd2ZXJ0aWNhbCcgPSAnaG9yaXpvbnRhbCc7XG4gICAgLyoqXG4gICAgICogU3BlY2lmaWVzIHRoZSBsYWJlbCBwb3NpdGlvbiBvZiB0aGUgY29tcG9uZW50LCB2YWxpZCB2YWx1ZXMgYXJlICdzdGFydCcgYW5kICdlbmQnLlxuICAgICAqIEBncm91cCBQcm9wc1xuICAgICAqL1xuICAgIEBJbnB1dCgpIGxhYmVsUG9zaXRpb246ICdzdGFydCcgfCAnZW5kJyA9ICdlbmQnO1xuICAgIC8qKlxuICAgICAqIFNwZWNpZmllcyB0aGUgbGFiZWwgb3JpZW50YXRpb24gb2YgdGhlIGNvbXBvbmVudCwgdmFsaWQgdmFsdWVzIGFyZSAnaG9yaXpvbnRhbCcgYW5kICd2ZXJ0aWNhbCcuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgbGFiZWxPcmllbnRhdGlvbjogJ2hvcml6b250YWwnIHwgJ3ZlcnRpY2FsJyB8IHVuZGVmaW5lZCA9ICdob3Jpem9udGFsJztcbiAgICAvKipcbiAgICAgKiBJbmxpbmUgc3R5bGUgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgc3R5bGU6IHsgW2tsYXNzOiBzdHJpbmddOiBhbnkgfSB8IG51bGwgfCB1bmRlZmluZWQ7XG4gICAgLyoqXG4gICAgICogU3R5bGUgY2xhc3Mgb2YgdGhlIGVsZW1lbnQuXG4gICAgICogQGdyb3VwIFByb3BzXG4gICAgICovXG4gICAgQElucHV0KCkgc3R5bGVDbGFzczogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gICAgZ2V0IHZlcnRpY2FsKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJztcbiAgICB9XG5cbiAgICBnZXQgY29udGFpbmVyQ2xhc3MoKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAncC1tZXRlcmdyb3VwIHAtY29tcG9uZW50JzogdHJ1ZSxcbiAgICAgICAgICAgICdwLW1ldGVyZ3JvdXAtaG9yaXpvbnRhbCc6IHRoaXMub3JpZW50YXRpb24gPT09ICdob3Jpem9udGFsJyxcbiAgICAgICAgICAgICdwLW1ldGVyZ3JvdXAtdmVydGljYWwnOiB0aGlzLm9yaWVudGF0aW9uID09PSAndmVydGljYWwnXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgQENvbnRlbnRDaGlsZCgnbGFiZWwnLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KSBsYWJlbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+IHwgdW5kZWZpbmVkO1xuXG4gICAgQENvbnRlbnRDaGlsZCgnbWV0ZXInLCB7IGRlc2NlbmRhbnRzOiBmYWxzZSB9KSBtZXRlclRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+IHwgdW5kZWZpbmVkO1xuXG4gICAgQENvbnRlbnRDaGlsZCgnZW5kJywgeyBkZXNjZW5kYW50czogZmFsc2UgfSkgZW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBAQ29udGVudENoaWxkKCdzdGFydCcsIHsgZGVzY2VuZGFudHM6IGZhbHNlIH0pIHN0YXJ0VGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBAQ29udGVudENoaWxkKCdpY29uJywgeyBkZXNjZW5kYW50czogZmFsc2UgfSkgaWNvblRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+IHwgdW5kZWZpbmVkO1xuXG4gICAgQENvbnRlbnRDaGlsZHJlbihQcmltZVRlbXBsYXRlKSB0ZW1wbGF0ZXM6IFF1ZXJ5TGlzdDxQcmltZVRlbXBsYXRlPiB8IHVuZGVmaW5lZDtcblxuICAgIF9sYWJlbFRlbXBsYXRlOiBUZW1wbGF0ZVJlZjxhbnk+IHwgdW5kZWZpbmVkO1xuXG4gICAgX21ldGVyVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBfZW5kVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBfc3RhcnRUZW1wbGF0ZTogVGVtcGxhdGVSZWY8YW55PiB8IHVuZGVmaW5lZDtcblxuICAgIF9pY29uVGVtcGxhdGU6IFRlbXBsYXRlUmVmPGFueT4gfCB1bmRlZmluZWQ7XG5cbiAgICBfY29tcG9uZW50U3R5bGUgPSBpbmplY3QoTWV0ZXJHcm91cFN0eWxlKTtcblxuICAgIEBWaWV3Q2hpbGQoJ2NvbnRhaW5lcicsIHsgcmVhZDogRWxlbWVudFJlZiB9KSBjb250YWluZXI6IEVsZW1lbnRSZWY7XG5cbiAgICBuZ0FmdGVyVmlld0luaXQoKSB7XG4gICAgICAgIHN1cGVyLm5nQWZ0ZXJWaWV3SW5pdCgpO1xuICAgICAgICBjb25zdCBfY29udGFpbmVyID0gdGhpcy5jb250YWluZXIubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZ2V0T3V0ZXJIZWlnaHQoX2NvbnRhaW5lcik7XG4gICAgICAgIHRoaXMudmVydGljYWwgJiYgKF9jb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gaGVpZ2h0ICsgJ3B4Jyk7XG4gICAgfVxuXG4gICAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgICAgICB0aGlzLnRlbXBsYXRlcz8uZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChpdGVtLmdldFR5cGUoKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xhYmVsJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFiZWxUZW1wbGF0ZSA9IGl0ZW0udGVtcGxhdGU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICAgICAgY2FzZSAnbWV0ZXInOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZXRlclRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdpY29uJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faWNvblRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICBjYXNlICdzdGFydCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0VGVtcGxhdGUgPSBpdGVtLnRlbXBsYXRlO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIGNhc2UgJ2VuZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2VuZFRlbXBsYXRlID0gaXRlbS50ZW1wbGF0ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHBlcmNlbnQobWV0ZXIgPSAwKSB7XG4gICAgICAgIGNvbnN0IHBlcmNlbnRPZkl0ZW0gPSAoKG1ldGVyIC0gdGhpcy5taW4pIC8gKHRoaXMubWF4IC0gdGhpcy5taW4pKSAqIDEwMDtcblxuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLm1heCgwLCBNYXRoLm1pbigxMDAsIHBlcmNlbnRPZkl0ZW0pKSk7XG4gICAgfVxuXG4gICAgcGVyY2VudFZhbHVlKG1ldGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlcmNlbnQobWV0ZXIpICsgJyUnO1xuICAgIH1cblxuICAgIG1ldGVyU3R5bGUodmFsKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHZhbC5jb2xvcixcbiAgICAgICAgICAgIHdpZHRoOiB0aGlzLm9yaWVudGF0aW9uID09PSAnaG9yaXpvbnRhbCcgJiYgdGhpcy5wZXJjZW50VmFsdWUodmFsLnZhbHVlKSxcbiAgICAgICAgICAgIGhlaWdodDogdGhpcy5vcmllbnRhdGlvbiA9PT0gJ3ZlcnRpY2FsJyAmJiB0aGlzLnBlcmNlbnRWYWx1ZSh2YWwudmFsdWUpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdG90YWxQZXJjZW50KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5wZXJjZW50KHRoaXMudmFsdWUucmVkdWNlKCh0b3RhbCwgdmFsKSA9PiB0b3RhbCArIHZhbC52YWx1ZSwgMCkpO1xuICAgIH1cblxuICAgIHBlcmNlbnRhZ2VzKCkge1xuICAgICAgICBsZXQgc3VtID0gMDtcbiAgICAgICAgY29uc3Qgc3Vtc0FycmF5ID0gW107XG5cbiAgICAgICAgdGhpcy52YWx1ZS5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgICAgICBzdW0gKz0gaXRlbS52YWx1ZTtcbiAgICAgICAgICAgIHN1bXNBcnJheS5wdXNoKHN1bSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHJldHVybiBzdW1zQXJyYXk7XG4gICAgfVxuXG4gICAgdHJhY2tCeUZuKGluZGV4OiBudW1iZXIpOiBudW1iZXIge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxufVxuXG5ATmdNb2R1bGUoe1xuICAgIGltcG9ydHM6IFtNZXRlckdyb3VwLCBTaGFyZWRNb2R1bGVdLFxuICAgIGV4cG9ydHM6IFtNZXRlckdyb3VwLCBTaGFyZWRNb2R1bGVdXG59KVxuZXhwb3J0IGNsYXNzIE1ldGVyR3JvdXBNb2R1bGUge31cbiJdfQ==